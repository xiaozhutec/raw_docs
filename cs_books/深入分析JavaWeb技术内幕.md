#### 《深入分析JavaWeb技术内幕》



###### 链接: https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ 提取码: vivd


《深入分析Java Web技术内幕（修订版）》新增了淘 宝在无线端的应用实践，包括：CDN 动态加速、多终端化改造、 多终端Session 统一 ，以及在大流量的情况下，如何跨越性能、网络和一个地区的电力瓶颈等内容，并提供了比较完整的解决方案。

《深入分析Java Web技术内幕（修订版）》主要围绕Java Web 相关技术从三方面全面、深入地进行了阐述。首先介绍前端知识，即在JavaWeb 开发中涉及的一些基本知识，包括Web 请求过程、HTTP、DNS 技术和CDN 技术。其次深入介绍了Java 技术，包括I/O 技术、中文编码问题、Javac 编译原理、class 文件结构解析、ClassLoader 工作机制及JVM 的内存管理等。最后介绍了Java 服务端技术，主要包括Servlet、Session 与Cookie、Tomcat 与Jetty服务器、Spring 容器、iBatis 框架和Velocity 框架等原理介绍，并介绍了服务端的一些优化技术。

《深入分析Java Web技术内幕（修订版）》不仅介绍这些技术和框架的工作原理，而且结合示例来讲解，通过通俗易懂的文字和丰富、生动的配图，让读者充分并深入理解它们的内部工作原理，同时还结合了设计模式来介绍这些技术背后的架构思维。



![](https://img2020.cnblogs.com/blog/2193560/202101/2193560-20210102214432722-1202086693.png)



```
目录
第1章 深入Web请求过程 1
1．1 B/S网络架构概述 2
1．2 如何发起一个请求 4
1．3 HTTP协议解析 6
1．3．1 查看HTTP信息的工具 8
1．3．2 浏览器缓存机制 9
1．4 DNS域名解析 12
1．4．1 DNS域名解析过程 12
1．4．2 跟踪域名解析过程 15
1．4．3 清除缓存的域名 18
1．4．4 几种域名解析方式 19
1．5 CDN工作机制 20
1．5．1 CDN架构 20
1．5．2 负载均衡 21
1．5．3 CDN动态加速 24
1．6 总结 25
第2章 深入分析Java I/O的工作机制 26
2．1 Java的I/O类库的基本架构 26
2．1．1 基于字节的I/O操作接口 27
2．1．2 基于字符的I/O操作接口 28
2．1．3 字节与字符的转化接口 29
2．2 磁盘I/O工作机制 30
2．2．1 几种访问文件的方式 30
2．2．2 Java访问磁盘文件 34
2．2．3 Java序列化技术 35
2．3 网络I/O工作机制 37
2．3．1 TCP状态转化 38
2．3．2 影响网络传输的因素 40
2．3．3 Java Socket的工作机制 40
2．3．4 建立通信链路 41
2．3．5 数据传输 42
2．4 NIO的工作方式 42
2．4．1 BIO带来的挑战 42
2．4．2 NIO的工作机制 43
2．4．3 Buffer的工作方式 46
2．4．4 NIO的数据访问方式 48
2．5 I/O调优 50
2．5．1 磁盘I/O优化 50
2．5．2 TCP网络参数调优 51
2．5．3 网络I/O优化 53
2．6 设计模式解析之适配器模式 57
2．6．1 适配器模式的结构 57
2．6．2 Java I/O中的适配器模式 58
2．7 设计模式解析之装饰器模式 58
2．7．1 装饰器模式的结构 59
2．7．2 Java I/O中的装饰器模式 59
2．8 适配器模式与装饰器模式的区别 60
2．9 总结 60
第3章 深入分析Java Web中的中文编码问题 61
3．1 几种常见的编码格式 61
3．1．1 为什么要编码 61
3．1．2 如何“翻译” 62
3．2 在Java中需要编码的场景 64
3．2．1 在I/O操作中存在的编码 64
3．2．2 在内存操作中的编码 66
3．3 在Java中如何编解码 67
3．3．1 按照ISO-8859-1编码 69
3．3．2 按照GB2312编码 70
3．3．3 按照GBK编码 71
3．3．4 按照UTF-16编码 71
3．3．5 按照UTF-8编码 72
3．3．6 UTF-8编码代码片段 72
3．3．7 对几种编码格式的比较 74
3．4 在Java Web中涉及的编解码 74
3．4．1 URL的编解码 76
3．4．2 HTTP Header的编解码 79
3．4．3 POST表单的编解码 79
3．4．4 HTTP BODY的编解码 80
3．5 JS中的编码问题 81
3．5．1 外部引入JS文件 81
3．5．2 JS的URL编码 82
3．5．3 其他需要编码的地方 84
3．6 常见问题分析 84
3．6．1 中文变成了看不懂的字符 84
3．6．2 一个汉字变成一个问号 85
3．6．3 一个汉字变成两个问号 85
3．6．4 一种不正常的正确编码 86
3．7 一种繁简转换的实现方式 87
3．8 总结 88
第4章 Javac编译原理 89
4．1 Javac是什么 90
4．2 Javac编译器的基本结构 90
4．3 Javac工作原理分析 92
4．3．1 词法分析器 93
4．3．2 语法分析器 100
4．3．3 语义分析器 105
4．3．4 代码生成器 115
4．4 设计模式解析之访问者模式 118
4．4．1 访问者模式的结构 119
4．4．2 Javac中访问者模式的实现 120
4．5 总结 121
第5章 深入class文件结构 122
5．1 JVM指令集简介 122
5．1．1 与类相关的指令 124
5．1．2 方法的定义 125
5．1．3 属性的定义 126
5．1．4 其他指令集 127
5．2 class文件头的表示形式 135
5．3 常量池 139
5．3．1 UTF8常量类型 142
5．3．2 Fieldref、Methodref常量类型 143
5．3．3 Class常量类型 143
5．3．4 NameAndType常量类型 144
5．4 类信息 144
5．5 Fields和Methods定义 145
5．6 类属性描述 149
5．7 Javap生成的class文件结构 150
5．7．1 LineNumberTable 152
5．7．2 LocalVariableTable 153
5．8 总结 155
第6章 深入分析ClassLoader工作机制 156
6．1 ClassLoader类结构分析 157
6．2 ClassLoader的等级加载机制 158
6．3 如何加载class文件 161
6．3．1 加载字节码到内存 161
6．3．2 验证与解析 163
6．3．3 初始化Class对象 163
6．4 常见加载类错误分析 163
6．4．1 ClassNotFoundException 163
6．4．2 NoClassDefFoundError 164
6．4．3 UnsatisfiedLinkError 165
6．4．4 ClassCastException 166
6．4．5 ExceptionInInitializerError 167
6．5 常用的ClassLoader分析 168
6．6 如何实现自己的ClassLoader 172
6．6．1 加载自定义路径下的class文件 172
6．6．2 加载自定义格式的class文件 174
6．7 实现类的热部署 176
6．8 Java应不应该动态加载类 178
6．9 总结 179
第7章 JVM体系结构与工作方式 180
7．1 JVM体系结构 180
7．1．1 何谓JVM 180
7．1．2 JVM体系结构详解 183
7．2 JVM工作机制 185
7．2．1 机器如何执行代码 185
7．2．2 JVM为何选择基于栈的架构 186
7．2．3 执行引擎的架构设计 187
7．2．4 执行引擎的执行过程 188
7．2．5 JVM方法调用栈 193
7．3 总结 197
第8章 JVM内存管理 198
8．1 物理内存与虚拟内存 199
8．2 内核空间与用户空间 200
8．3 在Java中哪些组件需要使用内存 201
8．3．1 Java堆 201
8．3．2 线程 201
8．3．3 类和类加载器 202
8．3．4 NIO 202
8．3．5 JNI 203
8．4 JVM内存结构 203
8．4．1 PC寄存器 204
8．4．2 Java栈 204
8．4．3 堆 205
8．4．4 方法区 205
8．4．5 运行时常量池 206
8．4．6 本地方法栈 206
8．5 JVM内存分配策略 206
8．5．1 通常的内存分配策略 207
8．5．2 Java中的内存分配详解 207
8．6 JVM内存回收策略 212
8．6．1 静态内存分配和回收 212
8．6．2 动态内存分配和回收 213
8．6．3 如何检测垃圾 213
8．6．4 基于分代的垃圾收集算法 215
8．7 内存问题分析 224
8．7．1 GC日志分析 224
8．7．2 堆快照文件分析 227
8．7．3 JVM Crash日志分析 227
8．8 实例1 233
8．9 实例2 235
8．10 实例3 237
8．11 总结 242

第9章 Servlet工作原理解析 243
9．1 从Servlet容器说起 243
9．1．1 Servlet容器的启动过程 244
9．1．2 Web应用的初始化工作 247
9．2 创建Servlet实例 249
9．2．1 创建Servlet对象 250
9．2．2 初始化Servlet 250
9．3 Servlet体系结构 252
9．4 Servlet如何工作 255
9．5 Servlet中的Listener 257
9．6 Filter如何工作 259
9．7 Servlet中的url-pattern 261
9．8 总结 262
第10章 深入理解Session与Cookie 263
10．1 理解Cookie 264
10．1．1 Cookie属性项 264
10．1．2 Cookie如何工作 265
10．1．3 使用Cookie的限制 268
10．2 理解Session 269
10．2．1 Session与Cookie 269
10．2．2 Session如何工作 270
10．3 Cookie安全问题 273
10．4 分布式Session框架 274
10．4．1 存在哪些问题 274
10．4．2 可以解决哪些问题 275
10．4．3 总体实现思路 275
10．5 Cookie压缩 280
10．6 表单重复提交问题 282
10．7 多终端Session统一 283
10．8 总结 285
第11章 Tomcat的系统架构与设计模式 286
11．1 Tomcat总体设计 286
11．1．1 Tomcat总体结构 287
11．1．2 Connector组件 293
11．1．3 Servlet容器Container 298
11．1．4 Tomcat中的其他组件 309
11．2 Tomcat中的设计模式 309
11．2．1 门面设计模式 309
11．2．2 观察者设计模式 311
11．2．3 命令设计模式 313
11．2．4 责任链设计模式 314
11．3 总结 316
第12章 Jetty的工作原理解析 317
12．1 Jetty的基本架构 317
12．1．1 Jetty的基本架构简介 317
12．1．2 Handler的体系结构 319
12．2 Jetty的启动过程 320
12．3 接受请求 321
12．3．1 基于HTTP协议工作 321
12．3．2 基于AJP工作 323
12．3．3 基于NIO方式工作 326
12．4 处理请求 327
12．5 与JBoss集成 330
12．6 与Tomcat的比较 331
12．6．1 架构比较 331
12．6．2 性能比较 332
12．6．3 特性比较 332
12．7 总结 333


第13章 Spring框架的设计理念与设计模式分析 334
13．1 Spring的骨骼架构 334
13．1．1 Spring的设计理念 335
13．1．2 核心组件如何协同工作 336
13．2 核心组件详解 337
13．2．1 Bean组件 337
13．2．2 Context组件 339
13．2．3 Core组件 340
13．2．4 Ioc容器如何工作 342
13．3 Spring中AOP的特性详解 352
13．3．1 动态代理的实现原理 352
13．3．2 Spring AOP如何实现 355
13．4 设计模式解析之代理模式 358
13．4．1 代理模式原理 358
13．4．2 Spring中代理模式的实现 358
13．5 设计模式解析之策略模式 361
13．5．1 策略模式原理 361
13．5．2 Spring中策略模式的实现 362
13．6 总结 362
第14章 Spring MVC工作机制与设计模式 364
14．1 Spring MVC的总体设计 364
14．2 Control设计 369
14．2．1 HandlerMapping初始化 370
14．2．2 HandlerAdapter初始化 372
14．2．3 Control的调用逻辑 373
14．3 Model设计 374
14．4 View设计 375
14．5 框架设计的思考 377
14．5．1 为什么需要框架 377
14．5．2 需要什么样的框架 377
14．5．3 框架设计的原则 378
14．5．4 “指航灯” 378
14．5．5 最基本的原则 378
14．6 设计模式解析之模板模式 379
14．6．1 模板模式的结构 379
14．6．2 Spring MVC中的模板模式示例 379
14．7 总结 380
第15章 深入分析Ibatis框架之系统架构与映射原理 381
15．1 Ibatis框架主要的类层次结构 381
15．2 Ibatis框架的设计策略 382
15．3 Ibatis框架的运行原理 384
15．4 示例 386
15．5 Ibatis对SQL语句的解析 388
15．6 数据库字段映射到Java对象 389
15．7 示例运行的结果 391
15．8 设计模式解析之简单工厂模式 391
15．8．1 简单工厂模式的实现原理 391
15．8．2 在Ibatis中的简单工厂模式示例 392
15．9 设计模式解析之工厂模式 393
15．9．1 工厂模式的实现原理 393
15．9．2 Ibatis中的工厂模式示例 394
15．10 总结 395
第16章 Velocity工作原理解析 397
16．1 Velocity总体架构 398
16．2 JJTree渲染过程解析 401
16．2．1 #set语法 405
16．2．2 Velocity的方法调用 406
16．2．3 #if、#elseif和#else语法 409
16．2．4 #foreach语法 410
16．2．5 #parse语法 412
16．3 事件处理机制 413
16．4 常用优化技巧 416
16．4．1 减少树的总节点数量 416
16．4．2 减少渲染耗时的节点数量 416
16．5 与JSP比较 417
16．5．1 JSP渲染机制 417
16．5．2 Velocity与JSP 423
16．6 设计模式解析之合成模式 423
16．6．1 合成模式的结构 423
16．6．2 Velocity中合成模式的实现 424
16．7 设计模式解析之解释器模式 425
16．7．1 解释器模式的结构 425
16．7．2 Velocity中解释器模式的实现 426
16．8 总结 426
第17章 Velocity优化实践 427
17．1 现实存在的问题 427
17．2 优化的理论基础 428
17．2．1 程序语言的三角形结构 428
17．2．2 数据结构减少抽象化 429
17．2．3 简单的程序复杂化 429
17．2．4 减少翻译的代价 430
17．2．5 变的转化为不变 430
17．3 一个高效的模板引擎的实现思路 430
17．3．1 vm模板如何被编译 432
17．3．2 方法调用的无反射优化 439
17．3．3 将字符输出改成字节输出 442
17．4 优化的成果 443
17．4．1 将char转成byte 443
17．4．2 无反射执行 444
17．5 其他优化手段 445
17．6 总结 445
第18章 大浏览量系统的静态化架构设计 446
18．1 淘宝大浏览量商品详情系统简介 446
18．2 系统面临哪些挑战 447
18．3 淘宝前台系统的优化历程 449
18．4 大浏览量系统的静态改造 449
18．4．1 什么是静态化系统 449
18．4．2 为什么要进行静态化架构设计 450
18．4．3 如何改造动态系统 451
18．4．4 几种静态化方案的设计及选择 453
18．4．5 如何解决失效问题 458
18．4．6 服务端静态化方案的演进：CDN化 459
18．5 总结 462
```




***

最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。[点击获取](https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw)

*本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com*





